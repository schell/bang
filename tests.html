<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8">
        <title>tests</title>
        <script src="mod.js" type="text/javascript" charset="utf-8"></script>
        <script src="http://schell.github.com/go/go.js" type="text/javascript" charset="utf-8"></script>
        <link rel="shortcut icon" href="favicon.png" />
    </head>
    <body id="tests">
        <script type="text/javascript" charset="utf-8">
            mod.useTagInjection = true;
            mod.expansions = {
                bang : 'src/'
            };
            mod({
                name : 'main',
                dependencies : [ 
                    'bang::Global.js',
                    'bang::View/Stage.js',
                    'bang::Utils/Pool.js'
                ],
                init : function initMain(m) {
                    return function exporter() {
                        return m;
                    };
                }
            }).onload(function afterload(m) {
                var assert = m.assert;
                var src = mod.compile();
                
                function newBangContext() {
                    /** * * 
                    * Evaluates a clean version of our code and gets the
                    * modules from our export function above..
                    * * **/
                    var main = eval(src);
                    var modules = main();
                    return modules;
                }
                
                var m1 = newBangContext();
                m.assert.eq('main' in m1, true, 'Can get new bang eval.');
                var m1stage = m1.Stage();
                
                var m2 = newBangContext();
                m.assert.eq('main' in m2, true, 'Can get another bang eval.');
                var m2stage = m2.Stage();
                
                m1stage.addListener(m1stage, m1.Stage.FRAME_TICK, function(note) {});
                
                assert.eq(m1stage.noteCenter.observers().length-1, m2stage.noteCenter.observers().length, 'Can add observers to bang context and contexts are seperate.');
                
                //--------------------------------------
                //  SOME TESTING HELPERS
                //--------------------------------------
                function initTestAndGetStage(modulesToInit) {
                    var b = newBangContext();
                    b.safeAddinAllPropertiesOf(modulesToInit, b);
                    var stage = modulesToInit.Stage();
                    stage.setParentElement(document.body);
                    modulesToInit.$testing = {
                        stage : stage
                    };
                    return stage;
                }
                function cleanUpTest(modulesToCleanUp) {
                    modulesToCleanUp.$testing.stage.remove();
                }
                //--------------------------------------
                //  TESTS
                //--------------------------------------
                function canGetMouseOverAfterMouseLeave(cb) {
                    console.log('canGetMouseOverAfterMouseLeave test');
                    
                    var b = {};
                    var stage = initTestAndGetStage(b);
                    assert.suite = 'canGetMouseOverAfterMouseLeave';
                    assert.eq('Stage' in b, true, 'Can init modules in test setup.');
                    
                    var over = false;
                    var moved = false;
                    // Add an interest in mouseLeave and mouseOver...
                    stage.addListener(stage, b.Stage.MOUSE_LEAVE, function() {
                        over = false;
                    });
                    stage.addListener(stage, b.View.MOUSE_MOVE, function() {
                        moved = true;
                    });
                    stage.addListener(stage, b.View.MOUSE_OVER, function() {
                        over = true;
                    });
                    // Send a fake mouse event...
                    stage.canvas.onmousemove({offsetX:1,offsetY:1});
                    assert.eq(over, true, 'Can get mouse over event.');
                    stage.canvas.onmousemove({offsetX:1,offsetY:1});
                    assert.eq(moved, true, 'Can get mouse move event.');
                    stage.canvas.onmouseout({offsetX:-100,offsetY:1});
                    assert.eq(over, false, 'Can get mouse leave event.');
                    stage.canvas.onmousemove({offsetX:1,offsetY:1});
                    assert.eq(over, true, 'Can get mouse over event again.');
                    
                    cleanUpTest(b);
                    cb();
                }
                
                function testPools(cb) {
                    var b = {};
                    var stage = initTestAndGetStage(b);
                    assert.suite = 'testPools';
                    
                    var creations = 0;
                    var draws = 0;
                    function createPoint() {
                        creations++;
                        return b.Matrix({
                            elements : [
                                Math.random()*stage.hitArea.width(),
                                Math.random()*stage.hitArea.height()
                            ]
                        });
                    }
                    function initPoint(p) {
                        // Do nothing...
                        p.elements[0] = Math.random()*stage.hitArea.width();
                        p.elements[1] = Math.random()*stage.hitArea.height();
                    }
                    function recyclePoint(p) {
                        p.elements[0] = 0;
                        p.elements[1] = 0;
                    }
                    
                    var time = 0;
                    function report() {
                        var millis = Date.now()-time;
                        var secs = millis/1000;
                        var fps = draws/secs;
                        
                        console.log('Created',creations,'objects and drew',draws,'frames in ',secs,'seconds(',fps,'fps).');
                        
                        time = 0;
                        draws = 0;
                        creations = 0;
                        
                        stage.removeListener(undefined, m.Stage.FRAME_TICK);
                        stage.drawQueue.length = 0;
                    }
                    
                    function stressItOut() {
                        /** * *
                        * This should make lots and lots of Points in random places,
                        * changing every frame...
                        * * **/
                        var points = [];
                        for (var i=0; i < 100; i++) {
                            points.push(createPoint());
                        }
                        // Reset the stage's drawQueue...
                        stage.drawQueue.length = 0;
                        // Push something to draw the rando points...
                        stage.drawQueue.push(function() {
                            draws++;
                            points.map(function(p) {
                                stage.context.fillRect(p.elements[0]-2,p.elements[1]-2,4,4);
                            });
                        });
                    }
                    
                    var pool = b.Pool.sharedInstance();
                    pool.addPond('RandomPoint', createPoint, initPoint, recyclePoint);
                    function usePools() {
                        /** * *
                        * This should make 100 Points in random places,
                        * and they will sit still...
                        * * **/
                        var points = [];
                        for (var i=0; i < 100; i++) {
                            points.push(pool.get('RandomPoint'));
                        }
                        // Reset the stage's drawQueue...
                        stage.drawQueue.length = 0;
                        // Push something to draw the rando points...
                        stage.drawQueue.push(function() {
                            draws++;
                            points.map(function(p) {
                                stage.context.fillRect(p.elements[0]-2,p.elements[1]-2,4,4);
                                pool.toss(p);
                            });
                        });
                    }
                    
                    stage.addListener(undefined, m.Stage.FRAME_TICK, stressItOut);
                    time = Date.now();
                    
                    var chugFor = 3000;
                    setTimeout(function() {
                        report();
                        
                        // Do the pool report...
                        stage.addListener(undefined, m.Stage.FRAME_TICK, usePools);
                        time = Date.now();
                        setTimeout(function() {
                            stage.removeListener(undefined, m.Stage.FRAME_TICK);
                            stage.drawQueue.length = 0;
                            
                            report();
                        }, chugFor)
                        
                    }, chugFor);
                    
                    //cb();
                }
                
                function testDirtyRectangles(cb) {
                    /** * *
                    * Tests bang's dirty rectangle implementation.
                    * * **/
                    assert.suite = 'testDirtyRectangles';
                    console.log(assert.suite);
                    var b = {};
                    var stage = window.stage = initTestAndGetStage(b);
                    stage.graphics.width = 500;
                    stage.graphics.height = 250;
                    stage.graphics.fillStyle = 'rgb(0, 0, 0)';
                    stage.graphics.fillRect(0, 0, 500, 250);
                    stage.graphics.fillStyle = 'rgb(255, 0, 0)';
                    stage.graphics.fillRect(10, 10, 10, 10);
                    var blue = m.View({
                        x : 10,
                        y : 10
                    });
                    blue.graphics.width = 50;
                    blue.graphics.height = 50;
                    blue.graphics.fillStyle = 'rgb(0,0,255)';
                    blue.graphics.fillRect(0, 0, 50, 50);
                    stage.addView(blue);
                    
                    assert.eq(stage.graphics.isDirty, true, 'Calling a draw function dirties the graphics context.');
                    stage.addListener(stage, m.Stage.FRAME_TICK, function() {
                        assert.eq(stage.graphics.isDirty, false, 'After frame update graphics context is not dirty.');
                        stage.removeListener(stage, m.Stage.FRAME_TICK);
                    });
                }
                
                
                go(
                    testDirtyRectangles,
                    canGetMouseOverAfterMouseLeave,
                    testPools,
                    m.assert.stat
                ).start();
            });
            
        </script>
    </body>
