<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8">
        <title>tests</title>
        <script src="mod.js" type="text/javascript" charset="utf-8"></script>
        <script src="http://schell.github.com/go/go.js" type="text/javascript" charset="utf-8"></script>
        <link rel="shortcut icon" href="favicon.png" />
    </head>
    <body id="tests">
        <script type="text/javascript" charset="utf-8">
            mod.useTagInjection = true;
            mod.expansions = {
                bang : 'src/'
            };
            mod({
                name : 'main',
                dependencies : [ 
                    'bang::Global.js',
                    'bang::View/Stage.js',
                    'bang::Utils/Pool.js'
                ],
                init : function initMain(m) {
                    return function exporter() {
                        return m;
                    };
                }
            }).onload(function afterload(m) {
                var assert = m.assert;
                var src = mod.compile();
                
                function newBangContext() {
                    /** * * 
                    * Evaluates a clean version of our code and gets the
                    * modules from our export function above..
                    * * **/
                    var main = eval(src);
                    var modules = main();
                    return modules;
                }
                
                var m1 = newBangContext();
                m.assert.eq('main' in m1, true, 'Can get new bang eval.');
                var m1stage = m1.Stage();
                
                var m2 = newBangContext();
                m.assert.eq('main' in m2, true, 'Can get another bang eval.');
                var m2stage = m2.Stage();
                
                m1stage.addListener(m1stage, m1.Stage.FRAME_TICK, function(note) {});
                
                assert.eq(m1stage.noteCenter.observers().length-1, m2stage.noteCenter.observers().length, 'Can add observers to bang context and contexts are seperate.');
                
                //--------------------------------------
                //  SOME TESTING HELPERS
                //--------------------------------------
                function initTestAndGetStage(modulesToInit) {
                    var b = newBangContext();
                    b.safeAddinAllPropertiesOf(modulesToInit, b);
                    var stage = modulesToInit.Stage();
                    stage.setParentElement(document.body);
                    modulesToInit.$testing = {
                        stage : stage
                    };
                    return stage;
                }
                function cleanUpTest(modulesToCleanUp) {
                    modulesToCleanUp.$testing.stage.remove();
                }
                //--------------------------------------
                //  TESTS
                //--------------------------------------
                function canGetMouseOverAfterMouseLeave(cb) {
                    console.log('canGetMouseOverAfterMouseLeave test');
                    
                    var b = {};
                    var stage = initTestAndGetStage(b);
                    assert.suite = 'canGetMouseOverAfterMouseLeave';
                    assert.eq('Stage' in b, true, 'Can init modules in test setup.');
                    
                    var over = false;
                    var moved = false;
                    // Add an interest in mouseLeave and mouseOver...
                    stage.addListener(stage, b.Stage.MOUSE_LEAVE, function() {
                        over = false;
                    });
                    stage.addListener(stage, b.View.MOUSE_MOVE, function() {
                        moved = true;
                    });
                    stage.addListener(stage, b.View.MOUSE_OVER, function() {
                        over = true;
                    });
                    // Send a fake mouse event...
                    stage.canvas.onmousemove({offsetX:1,offsetY:1});
                    assert.eq(over, true, 'Can get mouse over event.');
                    stage.canvas.onmousemove({offsetX:1,offsetY:1});
                    assert.eq(moved, true, 'Can get mouse move event.');
                    stage.canvas.onmouseout({offsetX:-100,offsetY:1});
                    assert.eq(over, false, 'Can get mouse leave event.');
                    stage.canvas.onmousemove({offsetX:1,offsetY:1});
                    assert.eq(over, true, 'Can get mouse over event again.');
                    
                    cleanUpTest(b);
                    cb();
                }
                
                function testPools(cb) {
                    var b = {};
                    var stage = initTestAndGetStage(b);
                    assert.suite = 'testPools';
                    
                    var creations = 0;
                    var draws = 0;
                    function createPoint() {
                        creations++;
                        return b.Matrix({
                            elements : [
                                Math.random()*stage.hitArea.width(),
                                Math.random()*stage.hitArea.height()
                            ]
                        });
                    }
                    function initPoint(p) {
                        // Do nothing...
                        p.elements[0] = Math.random()*stage.hitArea.width();
                        p.elements[1] = Math.random()*stage.hitArea.height();
                    }
                    function recyclePoint(p) {
                        p.elements[0] = 0;
                        p.elements[1] = 0;
                    }
                    
                    var time = 0;
                    function report() {
                        var millis = Date.now()-time;
                        var secs = millis/1000;
                        var fps = draws/secs;
                        
                        console.log('Created',creations,'objects and drew',draws,'frames in ',secs,'seconds(',fps,'fps).');
                        
                        time = 0;
                        draws = 0;
                        creations = 0;
                        
                        stage.removeListener(undefined, m.Stage.FRAME_TICK);
                        stage.drawQueue.length = 0;
                    }
                    
                    function stressItOut() {
                        /** * *
                        * This should make lots and lots of Points in random places,
                        * changing every frame...
                        * * **/
                        var points = [];
                        for (var i=0; i < 100; i++) {
                            points.push(createPoint());
                        }
                        // Reset the stage's drawQueue...
                        stage.drawQueue.length = 0;
                        // Push something to draw the rando points...
                        stage.drawQueue.push(function() {
                            draws++;
                            points.map(function(p) {
                                stage.context.fillRect(p.elements[0]-2,p.elements[1]-2,4,4);
                            });
                        });
                    }
                    
                    var pool = b.Pool.sharedInstance();
                    pool.addPond('RandomPoint', createPoint, initPoint, recyclePoint);
                    function usePools() {
                        /** * *
                        * This should make 100 Points in random places,
                        * and they will sit still...
                        * * **/
                        var points = [];
                        for (var i=0; i < 100; i++) {
                            points.push(pool.get('RandomPoint'));
                        }
                        // Reset the stage's drawQueue...
                        stage.drawQueue.length = 0;
                        // Push something to draw the rando points...
                        stage.drawQueue.push(function() {
                            draws++;
                            points.map(function(p) {
                                stage.context.fillRect(p.elements[0]-2,p.elements[1]-2,4,4);
                                pool.toss(p);
                            });
                        });
                    }
                    
                    stage.addListener(undefined, m.Stage.FRAME_TICK, stressItOut);
                    time = Date.now();
                    
                    var chugFor = 3000;
                    setTimeout(function() {
                        report();
                        
                        // Do the pool report...
                        stage.addListener(undefined, m.Stage.FRAME_TICK, usePools);
                        time = Date.now();
                        setTimeout(function() {
                            stage.removeListener(undefined, m.Stage.FRAME_TICK);
                            stage.drawQueue.length = 0;
                            
                            report();
                        }, chugFor)
                        
                    }, chugFor);
                    
                    //cb();
                }
                
                function breakupRectangles(cb) {
                    assert.suite = 'testDirtyRectangles';
                    console.log(assert.suite);
                    var b = {};
                    var width = 1000;
                    var height = 500;
                    var stage = document.createElement('canvas').getContext('2d');
                    stage.canvas.width = width;
                    stage.canvas.height = height;
                    console.log(stage,stage.canvas);
                    document.body.appendChild(stage.canvas);
                    
                    function makeRandomRects(j) {
                        var a = [];
                        for (var i=0; i < j; i++) {
                            var x,y,w,h;
                            x = Math.round(Math.random()*(250));
                            y = Math.round(Math.random()*250);
                            w = Math.round(Math.random()*(250-x));
                            h = Math.round(Math.random()*(250-y));
                            a.push(m.Rectangle.from(x,y,w,h));
                        }
                        return a;
                    };
                    var rects = [
                    //m.Rectangle.from(146,26,69,104),
                    //m.Rectangle.from(58,172,144,66),
                    //m.Rectangle.from(165,24,43,205),
                    //m.Rectangle.from(73,123,120,77),
                    ];
                    /*
                    for (var i=0; i < 10; i++) {
                        rects.push(m.Rectangle.from(i*10,i*10,100,100));
                    }
                    */
                    rects = makeRandomRects(10);
                    
                    window.printRectangleCode = function printRectangleCode() {
                        var s = '';
                        for (var i=0; i < rects.length; i++) {
                            var r = rects[i];
                            s += 'm.Rectangle.from(';
                            s += r.left()+',';
                            s += r.top()+',';
                            s += r.width()+',';
                            s += r.height();
                            s += '),\n';
                        }
                        console.log(s);
                    }
                    function drawRectangles(offset, rectangles, fill) {
                        stage.save();
                        if (offset) {
                            stage.translate(offset.x, offset.y);
                        }
                        for (var i=0; i < rectangles.length; i++) {
                            var rect = rectangles[i];
                            stage.fillStyle = fill;
                            stage.fillRect(rect.left(),rect.top(),rect.width(),rect.height());
                            stage.textBaseline = 'top';
                            stage.font = 'bold 10px sans-serif';
                            stage.fillStyle = 'black';
                            stage.strokeText(i.toString(), rect.left()+1, rect.top());
                            stage.fillStyle = 'white';
                            stage.fillText(i.toString(), rect.left()+1, rect.top());
                        }
                        stage.restore();
                    }
                    
                    function bundleRectangles(rectangles) {
                        var output = [];
                        for (var i=0; i < rectangles.length; i++) {
                            var rect = rectangles[i];
                            output.push({
                                id : i,
                                type : 's',
                                x : rect.left(),
                                intersections : [],
                                rectangle : rect,
                                toString : function() {
                                    return '['+this.type+' '+this.rectangle.left()+']';
                                }
                            });
                            output.push({
                                id : i,
                                type : 'e',
                                x : rect.right(),
                                intersections : [],
                                rectangle : rect,
                                toString : function() {
                                    return '['+this.type+' '+this.rectangle.left()+']';
                                }
                            });
                        }
                        function compareX(n1, n2) {
                            var diff = n1.x - n2.x;
                            if (diff === 0) {
                                return n1.top - n2.top;
                            }
                            return diff;
                        }
                        output.sort(compareX);
                        return output;
                    }
                    
                    window.updateReduction = function(input, output, current, scans, e) {
                        var inputColor = 'rgba(127,127,0,0.5)';
                        var outputColor = 'rgba(255,0,0,0.5)';
                        var currentColor = 'rgba(127,0,127,0.3)';
                        var scansColor = 'rgba(0,127,127,0.5)';
                        var eventColor = 'black';
                        stage.save();
                        stage.clearRect(0,0,width,height);
                        if (input) {
                            drawRectangles({x:0,y:0}, input, inputColor);
                        }
                        if (current) {
                            drawRectangles({x:0,y:0}, current, currentColor);
                        }
                        if (scans) {
                            drawRectangles({x:250,y:0}, scans, scansColor);
                        }
                        if (output) {
                            drawRectangles({x:250,y:0}, output, outputColor);
                        }
                        if (e) {
                            stage.fillRect(e.x,e.rectangle.top(),1,e.rectangle.height());
                            stage.textBaseline = 'top';
                        }
                        stage.restore();
                    }
                    function reduceRectangles(rectangles) {
                        /** * *
                        * Returns a new set of rectangles that do not intersect, that occupy the
                        * same space as the original.
                        * @return Array
                        * * **/
                        
                        var input = rectangles.slice();
                        var events = bundleRectangles(input);
                        var current = [];
                        var scans = [];
                        var output = [];
                        
                        for (var i=0; i < events.length; i++) {
                            var e = events[i];
                            
                            // Update the current scans...
                            for (var j=0; j < scans.length; j++) {
                                var scan = scans[j];
                                scan.right(e.x);
                            }
                            
                            if (e.type === 's') {
                                var contained = false;
                                for (var j=0; j < current.length; j++) {
                                    var currentRect = current[j];
                                    if (currentRect.containsRectangle(e.rectangle)) {
                                        contained = true;
                                        break;
                                    }
                                }
                                if (!contained) {
                                    // This event should start a new rectangle (at some point)...
                                    current.push(e.rectangle);
                                    var intersected = false;
                                    for (var j=0; j < scans.length; j++) {
                                        var scan = scans[j];
                                        if (!(e.rectangle.top() >= scan.bottom() || scan.top() >= e.rectangle.bottom())) {
                                            // The scan and event intersect in y...
                                            if ((e.rectangle.top() >= scan.top() && e.rectangle.bottom() <= scan.bottom())) {
                                                // This scan contains the event's rectangle, so we don't need to make a new scan
                                                // but we will need to know that it intersects...
                                                scan.intersects.push(e.rectangle);
                                                contained = true;
                                                continue;
                                            }
                                            // We have to check if it has a width, if not, it was added by an earlier intersection
                                            // during this event...
                                            if (scan.width()) {
                                                // This scan was from an earlier event, so output a rectangle...
                                                output.push(scan);
                                            }
                                            // Replace this scan with a scan that represents the intersection...
                                            var t = Math.min(e.rectangle.top(), scan.top());
                                            var b = Math.max(e.rectangle.bottom(), scan.bottom());
                                            if (intersected) {
                                                // We've already created one intersection, so group it with this one...
                                                intersected.top(Math.min(intersected.top(), t));
                                                intersected.bottom(Math.max(intersected.bottom(), b));
                                                intersected.intersects = intersected.intersects.concat(scan.intersects);
                                            } else {
                                                intersected = m.Rectangle.from(e.x, t, 0, b - t);
                                                intersected.intersects = scan.intersects.concat([e.rectangle]);
                                            }
                                            // Get rid of the current scan...
                                            scans.splice(j--, 1);
                                        }
                                    }
                                    if (!contained) {
                                        // This rectangle is not contained by a current scan either...
                                        if (!intersected) {
                                            // This event starts a new non-overlapping rectangle...
                                            var r = e.rectangle.copy();
                                            r.intersects = [e.rectangle];
                                            scans.push(r);
                                        } else {
                                            scans.push(intersected);
                                        }
                                    }
                                }
                            } else {
                                // This is an end event...
                                for (var j=0; j < current.length; j++) {
                                    var currentRect = current[j];
                                    if (currentRect.isEqualTo(e.rectangle)) {
                                        current.splice(j, 1);
                                        break;
                                    }
                                }
                                for (var j=0; j < scans.length; j++) {
                                    var scan = scans[j];
                                    // Find the scan that intersects this end event...
                                    if (scan.intersects.length === 1 && scan.top() === e.rectangle.top() && scan.bottom() === e.rectangle.bottom()) {
                                        // This end event corresponds specifically to this scan, so output it...
                                        output.push(scan);
                                        scans.splice(j--, 1);
                                    } else {
                                        // We're going to have to break this scan up into subscans...
                                        var ndx = scan.intersects.indexOf(e.rectangle);
                                        if (ndx !== -1) {
                                            // Output the scan, because we have to change it...
                                            output.push(scan);
                                            // Remove this rectangle from the intersecting scan...
                                            scan.intersects.splice(ndx, 1);
                                            // Remove the scan from our scans...
                                            scans.splice(j, 1);
                                            if (scan.intersects.length) {
                                                // Make some new scans to replace the old one...
                                                var newScans = scan.intersects.map(function(el) {
                                                    var newScan = m.Rectangle.from(e.x, el.top(), 0, el.height());
                                                    newScan.intersects = [el];
                                                    return newScan;
                                                });
                                                // Iterate through the new scans and collect them together if they overlap...
                                                var newScanNdx = 0;
                                                while (newScans.length > 1 && newScanNdx < newScans.length) {
                                                    var intersection = newScans[newScanNdx++];
                                                    for (var l=0; l < newScans.length; l++) {
                                                        if (l === newScanNdx-1) {
                                                            // We don't want to compare a scan to itself...
                                                            continue;
                                                        }
                                                        var newScan = newScans[l];
                                                        if (!(newScan.top() > intersection.bottom() || intersection.top() > newScan.bottom())) {
                                                            // The two overlap, so absorb the intersection scan into this scan...
                                                            intersection.top(Math.min(newScan.top(), intersection.top()));
                                                            intersection.bottom(Math.max(newScan.bottom(), intersection.bottom()));
                                                            intersection.intersects = newScan.intersects.concat(intersection.intersects);
                                                            // Now we have to test this scan against the others again, since it has changed...
                                                            newScans.splice(l, 1);
                                                            newScanNdx = 0;
                                                            break;
                                                        }
                                                    }
                                                }
                                                // Add the new scans to scans...
                                                scans = scans.concat(newScans);
                                            }
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        // Concat the remaining scans in there...
                        return output.concat(scans);
                    }
                    var time = Date.now();
                    var optimized = reduceRectangles(rects);
                    var total = Date.now() - time;
                    updateReduction(rects,optimized);
                    function stats(input, output) {
                        var inputArea = 0;
                        var outputArea = 0;
                        var r = m.Rectangle.from(Math.POSITIVE_INFINITY,Math.POSITIVE_INFINITY,Math.NEGATIVE_INFINITY,Math.NEGATIVE_INFINITY);
                        input.map(function(el) {
                            inputArea += el.area();
                            if (el.left() < r.left()) {
                                r.left(el.left());
                            }
                            if (el.right() > r.right()) {
                                r.right(el.right());
                            }
                            if (el.top() < r.top()) {
                                r.top(el.top());
                            }
                            if (el.bottom() > r.bottom()) {
                                r.bottom(el.bottom());
                            }
                        });
                        output.map(function(el) {
                            outputArea += el.area();
                        });
                        var wastedRedraw = r.area() - outputArea;
                        stage.strokeRect(r.left()+250,r.top(),r.width(),r.height());
                        console.log(rects.length,'('+inputArea+'px^2) -> ',optimized.length,'('+outputArea+'px^2) '+total+'ms',inputArea,outputArea,wastedRedraw);
                    }
                    stats(rects,optimized);
                }
                
                function testDirtyRectangles(cb) {
                    /** * *
                    * Tests bang's dirty rectangle implementation.
                    * * **/
                    assert.suite = 'testDirtyRectangles';
                    console.log(assert.suite);
                    var b = {};
                    var stage = window.stage = initTestAndGetStage(b);
                    stage.graphics.width = 500;
                    stage.graphics.height = 250;
                    stage.graphics.fillStyle = 'rgb(0, 0, 0)';
                    stage.graphics.fillRect(0, 0, 500, 250);
                    stage.graphics.fillStyle = 'rgb(255, 0, 0)';
                    stage.graphics.fillRect(10, 10, 10, 10);
                    var blue = m.View({
                        x : 10,
                        y : 10
                    });
                    blue.graphics.width = 50;
                    blue.graphics.height = 50;
                    blue.graphics.fillStyle = 'rgb(0,0,255)';
                    blue.graphics.fillRect(0, 0, 50, 50);
                    stage.addView(blue);
                    
                    assert.eq(stage.graphics.isDirty, true, 'Calling a draw function dirties the graphics context.');
                    stage.addListener(stage, m.Stage.FRAME_TICK, function() {
                        assert.eq(stage.graphics.isDirty, false, 'After frame update graphics context is not dirty.');
                        stage.removeListener(stage, m.Stage.FRAME_TICK);
                    });
                }
                
                
                go(
                    breakupRectangles,
                    testDirtyRectangles,
                    canGetMouseOverAfterMouseLeave,
                    testPools,
                    m.assert.stat
                ).start();
            });
            
        </script>
    </body>
